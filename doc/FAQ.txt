Frequently Asked Questions
==========================

See also the notes on compatibility_ to ElementTree_.

.. _compatibility: compatibility.html
.. _ElementTree:   http://effbot.org/zone/element-index.htm


#) Is there a tutorial?

   There is a `tutorial for ElementTree`_ which also works for lxml.etree.
   The `API documentation`_ also contains many examples.

   .. _`tutorial for ElementTree`: http://effbot.org/zone/element.htm
   .. _`API documentation`:        api.html


#) Where can I find more documentation about lxml?

   There is a lot of documentation as lxml implements the well-known
   `ElementTree API`_ and tries to follow its documentation as closely as
   possible.  There are a couple of issues where lxml cannot keep up
   compatibility.  They are described in the compatibility_ documentation.
   The lxml specific extensions to the API are described by individual files
   in the ``doc`` directory of the distribution and on `the web page`_.

   .. _`ElementTree API`: http://effbot.org/zone/element-index.htm
   .. _`the web page`:    http://codespeak.net/lxml/#documentation


#) My application crashes! Why does lxml.etree do that?

   a) If you are using threads, make sure that you are not sharing non
      thread-safe objects between threads.  Especially the default parser,
      XSLT() and the validators are not thread-safe for performance reasons.
      You have to create a new one for each thread, use a thread-safe object
      pool or assure thread-safe access to them yourself.

   b) One of the goals of lxml is "no segfaults", so if there is no clear
      warning in the documentation that you were doing something potentially
      harmful, you have found a bug and we would like to hear about it.
      Please report this bug to the mailing list.  See the next section on how
      to do that.


#) I think I have found a bug in lxml. What should I do?

   a) First, you should look at the `current developer changelog`_ to see if
      this is a known problem that has already been fixed in the SVN trunk.

      .. _`current developer changelog`: http://codespeak.net/svn/lxml/trunk/CHANGES.txt

   b) Otherwise, we would really like to hear about it.  Please report it to
      the `mailing list`_ so that we can fix it.  It is very helpful in this
      case if you can come up with a short code snippet that demonstrates your
      problem.  Please also report the version of lxml, libxml2 and libxslt
      that you are using (see the module attributes ``etree.LXML_VERSION``
      etc.).

      .. _`mailing list`: http://codespeak.net/mailman/listinfo/lxml-dev


#) Can I use threads to concurrently access the lxml API?

   You should be able to use lxml in a multi-threaded environment, although
   this is not very well tested.  Note that lxml does not provide any
   thread-safety by itself (mainly for performance reasons), so you have to
   take care when you use parts of the API concurrently.  Most importantly,
   you must not forget to call ``etree.initThread()`` from each newly
   generated thread to initialize lxml and libxml2 for the new thread context.
   If you call API functions from a thread without having called this function
   first, lxml can easily crash your program.

   Basically none of the API classes is thread-safe, including parsers, XPath,
   XSLT and the validators.  You cannot use such an object concurrently.
   However, it is perfectly viable to create independent instances for each
   thread.  This is a cheap thing to do for parsers, but more expensive for
   XSLT and validators, which have to compile trees recursively.  So you might
   want to consider a thread pool approach or threaded processing chains to
   reduce the overhead if you require threading here.


#) What are the ``findall()`` and ``xpath()`` methods on Element(Tree)?

   ``findall()`` is part of the original `ElementTree API`_.  It supports a
   `simple subset of the XPath language`_, without predicates, conditions and
   other advanced features.  It is very handy for finding specific tags in a
   tree.  Another important difference is namespace handling, which uses the
   ``{namespace}tagname`` notation.  This is not supported by XPath.  The
   findall, find and findtext methods are compatible with other ElementTree
   implementations and allow writing portable code that runs on ElementTree,
   cElementTree and lxml.etree.

   ``xpath()``, on the other hand, supports the complete power of the XPath
   language, including predicates, XPath functions and Python extension
   functions.  The syntax is defined by the `XPath specification`_.  If you
   need the expressiveness and selectivity of XPath, the ``xpath()`` method,
   the ``XPath`` class and the ``XPathEvaluator`` are the best choice_.

   .. _`simple subset of the XPath language`: http://effbot.org/zone/element-xpath.htm
   .. _`XPath specification`:                 http://www.w3.org/TR/xpath
   .. _choice:                                performance.html#xpath


#) Why doesn't ``findall()`` support full XPath expressions?

   It was decided that it is more important to keep compatibility with
   ElementTree_ to simplify code migration between the libraries.  The main
   difference compared to XPath is the ``{namespace}tagname`` notation used in
   ``findall()``, which is not valid XPath.

   ElementTree and lxml.etree use the same implementation, which assures 100%
   compatibility.  Note that ``findall()`` is `so fast`_ in lxml that a native
   implementation would not bring any performance benefits.

   .. _`so fast`: performance.html#tree-traversal


#) What is the difference between str(xslt(doc)) and xslt(doc).write() ?

   The str() implementation of the XSLTResultTree class (a subclass of
   ElementTree) knows about the output method chosen in the stylesheet
   (xsl:output), write() doesn't.  If you call write(), the result will be a
   normal XML tree serialization in the requested encoding.  Calling this
   method may also fail for XSLT results that are not XML trees (e.g. string
   results).

   If you call str(), it will return the serialized result as specified by the
   XSL transform.  This correctly serializes string results to encoded Python
   strings and honours ``xsl:output`` options like ``indent``.  This almost
   certainly does what you want, so you should only use ``write()`` if you are
   sure that the XSLT result is an XML tree and you want to override the
   encoding and indentation options requested by the stylesheet.


#) Why is my application so slow?

   lxml.etree is a very fast library for processing XML.  There are, however,
   `a few caveats`_ involved in the mapping of the powerful libxml2 library to
   the simple and convenient ElementTree API.  Not all operations are as fast
   as the simplicity of the API might suggest.  The `benchmark page`_ has a
   comparison to other ElementTree implementations and a number of tips for
   performance tweaking.

   .. _`a few caveats`:  performance.html#the-elementtree-api
   .. _`benchmark page`: performance.html

